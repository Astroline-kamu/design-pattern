# 结构

- 创建型模式 (Niyredra)
    1. 工厂模式
        1. [简单工厂模式](./demo/niyredra/factory/simple)
        2. [工厂方法模式](./demo/niyredra/factory/normal)
        3. [抽象工厂模式](./demo/niyredra/factory/abstr)
    2. 单例模式
    3. 原型模式
    4. 建造者模式
- 结构型模式 (Calarasas)
    1. 适配器模式
    2. 桥接模式
    3. 组合模式
    4. 装饰模式
    5. 代理模式
    6. 外观模式
    7. 亨元模式
- 行为型模式 (phiplouwxz)
    1. 职责链模式
    2. 命令模式
    3. 解释器模式
    4. 迭代器模式
    5. 中介者模式
    6. 备忘录模式
    7. 观察者模式
    8. 状态模式
    9. 策略模式
    10. 模版方法模式
    11. 访问者模式

# 说明

爪爪为了让代码易于理解，就把每一个项目单独存放了，没有去将业务相关的东西抽象上去。
这么做爪爪看着很难受，但是爪爪知道这是必要的————

# 使用

如何运行：

每一个目录下都会有一个Application类，直接编译执行即可。

# 测试

测试部分其实设计不是很好，原预期准备写类似Junit那种直接调用的，但是我印象里那个直接执行还是靠IDE的插件，所以丢到后期了；

测试类有一个专门的方法，TestApplication，执行则将所有的demo结果都运行出来awa

抽象出父级貌似就是只能干这事...(理论上用注解也可以把Class标注进去，就不用写extends了...)

## 后续

protobuf是个好东西，在最终的example中我会用到它的

2022-09-19
> 有时候我不禁会想，设计模式究竟是用来描述，还是用来实现————实现本身也是对业务的一种描述，这确实，但最好不要让它的概念敞口同时包含描述和实现两个概念。
> 所以，不管日志的实现也好，还是说去描述刺蛇和变异结果的关系，它们都可以是业务或者是描述。造成这种感知差距的原因在于后续，刺蛇没有后续，日志可以记录，大概就这么些。


# 关于使用的包

IDEA - `command + ;` ->> Libraries ->> form maven (理论上我的jar包是也上传到项目中的，所以代码下下来之后直接引用本地文件就好 文件地址在根目录的lib下 或者你也是idea，就不用改啦～)

Lombok ---- 我真的不想再写getter and setter了啊～～


# 写在最后

写东西容易啊～
但是想规约，就没这么容易了。
我不是那种可以想哪里就写哪里的龙，我们都不是。

内容参考：https://blog.csdn.net/LoveLion/article/details/17517213




我对建造者想法是，

